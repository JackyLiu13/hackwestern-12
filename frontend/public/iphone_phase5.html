<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>iPhone 15 Repair - Phase 5: Transferring Components</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f0f0;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            font-family: 'Inter', sans-serif;
            pointer-events: none;
            color: #333;
        }

        #instructions {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        #sub-instructions {
            font-size: 1em;
            color: #555;
            max-width: 800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 8px;
        }
    </style>
</head>

<body>
    <div id="info">
        <div id="instructions">Phase 5: Transferring Components</div>
        <div id="sub-instructions">
            Check your new part. If needed, transfer the <strong>Sensor Assembly</strong> (Face ID/Mic) from the old
            screen.<br>
            Use heat and gentle prying. <strong>Do not damage!</strong>
        </div>
    </div>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf5f5f7);
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 100, 100);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 0, 0);
        controls.update();

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 100, 50); dirLight.castShadow = true;
        scene.add(dirLight);

        // Materials
        const screenBackMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 }); // Back of screen
        const sensorMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.5 });
        const goldMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8 });

        // Old Screen (Broken)
        const oldScreen = new THREE.Group();
        const osMesh = new THREE.Mesh(new THREE.BoxGeometry(35, 1, 70), screenBackMat);
        oldScreen.add(osMesh);
        oldScreen.position.set(-40, 0, 0);
        scene.add(oldScreen);

        // New Screen (Clean)
        const newScreen = new THREE.Group();
        const nsMesh = new THREE.Mesh(new THREE.BoxGeometry(35, 1, 70), screenBackMat);
        newScreen.add(nsMesh);
        newScreen.position.set(40, 0, 0);
        scene.add(newScreen);

        // Sensor Assembly
        const sensorGroup = new THREE.Group();
        const bracket = new THREE.Mesh(new THREE.BoxGeometry(15, 2, 5), sensorMat);
        const mic = new THREE.Mesh(new THREE.BoxGeometry(3, 1, 3), goldMat); mic.position.set(4, 1, 0);
        const prox = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 1), new THREE.MeshStandardMaterial({ color: 0x111111 })); prox.position.set(-3, 1, 0);
        sensorGroup.add(bracket); sensorGroup.add(mic); sensorGroup.add(prox);

        // Start position: Top of Old Screen
        sensorGroup.position.set(-40, 2, -30);
        scene.add(sensorGroup);

        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // Animation: Move from Old to New
            if (time < 1) {
                // Lift up
                sensorGroup.position.y = 2 + time * 10;
            } else if (time < 3) {
                // Move across
                const t = (time - 1) / 2; // 0 to 1
                sensorGroup.position.x = -40 + (t * 80);
            } else if (time < 4) {
                // Lower down
                const t = (time - 3);
                sensorGroup.position.y = 12 - (t * 10);
            }

            controls.update();
            renderer.render(scene, camera);
        }
        animate();
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>

</html>