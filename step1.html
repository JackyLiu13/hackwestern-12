<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>IKEA SMÅGÖRA Assembly - Step 1: Preparation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f0f0;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            font-family: Arial, sans-serif;
            pointer-events: none;
            color: #333;
        }

        #instructions {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        #sub-instructions {
            font-size: 0.9em;
            color: #555;
        }
    </style>
</head>

<body>
    <div id="info">
        <div id="instructions">Step 1: Preparation</div>
        <div id="sub-instructions">Unpack all parts and organize them on a soft surface.</div>
    </div>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xe0e0e0);
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 250, 150);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 0, 0);
        controls.update();

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(50, 200, 100); dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(2048, 2048); scene.add(dirLight);
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(600, 600), new THREE.MeshStandardMaterial({ color: 0xb0b0b0, roughness: 1.0 }));
        ground.rotation.x = -Math.PI / 2; ground.position.y = -0.1; ground.receiveShadow = true; scene.add(ground);

        const whiteWoodMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.6, metalness: 0.1 });
        const rawWoodMat = new THREE.MeshStandardMaterial({ color: 0xd2b48c, roughness: 0.8 });

        // --- STRICT GEOMETRY DEFINITIONS ---
        // End Panel: 70W x 75H x 2.5D
        // Side Panel: 130L x 70H x 2.5D

        function createEndPanel() {
            const width = 70; const height = 75; const thickness = 2.5;
            const shape = new THREE.Shape();
            // Drawn in XY plane. Center at (0,0)
            shape.moveTo(-width / 2, -height / 2);
            shape.lineTo(width / 2, -height / 2);
            shape.lineTo(width / 2, height / 2 - 10); // Top curve start
            shape.quadraticCurveTo(0, height / 2, -width / 2, height / 2 - 10);
            shape.lineTo(-width / 2, -height / 2);

            const geo = new THREE.ExtrudeGeometry(shape, { depth: thickness, bevelEnabled: false });
            geo.center(); // Center at 0,0,0
            const mesh = new THREE.Mesh(geo, whiteWoodMat); mesh.castShadow = true; return mesh;
        }

        function createSidePanel() {
            const group = new THREE.Group();
            const length = 130; const height = 70; const thickness = 2.5;
            // Rails (Top/Bottom) - Length along X
            const railGeo = new THREE.BoxGeometry(length, 5, thickness);
            const topRail = new THREE.Mesh(railGeo, whiteWoodMat); topRail.position.y = height / 2 - 2.5; topRail.castShadow = true; group.add(topRail);
            const botRail = new THREE.Mesh(railGeo, whiteWoodMat); botRail.position.y = -height / 2 + 2.5; botRail.castShadow = true; group.add(botRail);

            // Bars - Vertical (Y)
            const barGeo = new THREE.CylinderGeometry(0.8, 0.8, height - 10, 16);
            for (let i = 0; i < 15; i++) {
                const bar = new THREE.Mesh(barGeo, whiteWoodMat);
                bar.position.x = -length / 2 + 10 + (i * (length - 20) / 14);
                bar.castShadow = true;
                group.add(bar);
            }
            return group;
        }

        function createMattressBase() {
            const group = new THREE.Group(); const length = 126; const width = 64;
            const frameThickness = 3; const slatThickness = 1;
            // Frame
            const frameSide1 = new THREE.Mesh(new THREE.BoxGeometry(length, frameThickness, frameThickness), rawWoodMat); frameSide1.position.z = width / 2 - frameThickness / 2; group.add(frameSide1);
            const frameSide2 = frameSide1.clone(); frameSide2.position.z = -width / 2 + frameThickness / 2; group.add(frameSide2);
            // Slats
            const slatGeo = new THREE.BoxGeometry(5, slatThickness, width - frameThickness * 2);
            for (let i = 0; i < 12; i++) { const slat = new THREE.Mesh(slatGeo, rawWoodMat); slat.position.x = -length / 2 + (i + 1) * (length / 13); slat.castShadow = true; group.add(slat); }
            return group;
        }

        // --- LAYOUT (All Flat) ---

        // End Panels
        const end1 = createEndPanel(); end1.rotation.x = -Math.PI / 2; end1.position.set(-80, 1.25, -50); scene.add(end1);
        const end2 = createEndPanel(); end2.rotation.x = -Math.PI / 2; end2.position.set(-80, 1.25, 50); scene.add(end2);

        // Side Panels
        const side1 = createSidePanel(); side1.rotation.x = -Math.PI / 2; side1.position.set(50, 1.25, -50); scene.add(side1);
        const side2 = createSidePanel(); side2.rotation.x = -Math.PI / 2; side2.position.set(50, 1.25, 50); scene.add(side2);

        // Base
        const base = createMattressBase(); base.rotation.x = -Math.PI / 2; base.position.set(0, 1.25, 150); scene.add(base);

        function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
        animate();
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>

</html>