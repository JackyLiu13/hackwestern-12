<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>IKEA SMÅGÖRA Assembly - Step 4: Attach second end panel</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f0f0;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            font-family: Arial, sans-serif;
            pointer-events: none;
            color: #333;
        }

        #instructions {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        #sub-instructions {
            font-size: 0.9em;
            color: #555;
        }
    </style>
</head>

<body>
    <div id="info">
        <div id="instructions">Step 4: Attach the second end panel</div>
        <div id="sub-instructions">Align the second end panel with the side panels and secure with screws.</div>
    </div>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xe0e0e0);
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(150, 200, 150);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 65, 0);
        controls.update();

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(50, 200, 100); dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(2048, 2048); scene.add(dirLight);
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(500, 500), new THREE.MeshStandardMaterial({ color: 0xb0b0b0, roughness: 1.0 }));
        ground.rotation.x = -Math.PI / 2; ground.position.y = -0.1; ground.receiveShadow = true; scene.add(ground);

        const whiteWoodMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.6, metalness: 0.1 });
        const metalMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.7, roughness: 0.3 });

        function createEndPanel() {
            const width = 70; const height = 75; const thickness = 2.5;
            const shape = new THREE.Shape();
            shape.moveTo(-width / 2, -height / 2); shape.lineTo(width / 2, -height / 2);
            shape.lineTo(width / 2, height / 2 - 10); shape.quadraticCurveTo(0, height / 2, -width / 2, height / 2 - 10);
            shape.lineTo(-width / 2, -height / 2);
            const geo = new THREE.ExtrudeGeometry(shape, { depth: thickness, bevelEnabled: false });
            geo.center();
            const mesh = new THREE.Mesh(geo, whiteWoodMat); mesh.castShadow = true; return mesh;
        }

        function createSidePanelVertical() {
            const group = new THREE.Group();
            const length = 130; const height = 70; const thickness = 2.5;
            const railGeo = new THREE.BoxGeometry(thickness, length, 5);
            const leftRail = new THREE.Mesh(railGeo, whiteWoodMat); leftRail.position.z = -height / 2 + 2.5; group.add(leftRail);
            const rightRail = new THREE.Mesh(railGeo, whiteWoodMat); rightRail.position.z = height / 2 - 2.5; group.add(rightRail);
            const barGeo = new THREE.CylinderGeometry(0.8, 0.8, height - 10, 16);
            for (let i = 0; i < 15; i++) {
                const bar = new THREE.Mesh(barGeo, whiteWoodMat);
                bar.rotation.x = Math.PI / 2;
                bar.position.y = -length / 2 + 10 + (i * (length - 20) / 14);
                group.add(bar);
            }
            return group;
        }

        function createHexKey() {
            const hexKey = new THREE.Mesh(new THREE.TorusGeometry(2, 0.4, 8, 24, Math.PI / 1.5), metalMat);
            hexKey.castShadow = true; return hexKey;
        }

        // --- ASSEMBLY ---
        // End Panel 1 (Flat on floor)
        const end1 = createEndPanel();
        end1.rotation.x = -Math.PI / 2;
        end1.position.set(0, 1.25, 0);
        scene.add(end1);

        // Side Panels (Vertical)
        const side1 = createSidePanelVertical();
        side1.position.set(-33.75, 65, 2.5);
        scene.add(side1);

        const side2 = createSidePanelVertical();
        side2.position.set(33.75, 65, 2.5);
        scene.add(side2);

        // End Panel 2 (Top Lid)
        // Position Y = 130 (Length) + 1.25 (Half Thickness) - 1.25 (End 1 Thickness)?
        // Side Length 130. Starts at Y=0? No, Y=65 center.
        // Side Bottom at Y=0. Top at Y=130.
        // End 1 Top Face at Y=2.5.
        // So Side sits on Y=2.5?
        // Let's adjust Side Y.
        // Side Length 130. Center Y = 65 + 2.5 = 67.5.
        side1.position.y = 67.5;
        side2.position.y = 67.5;

        // End 2 sits on top of Sides. Y = 130 + 2.5 = 132.5.
        // Center Y = 132.5 + 1.25 = 133.75.
        const end2 = createEndPanel();
        end2.rotation.x = -Math.PI / 2;
        end2.rotation.y = Math.PI; // Flip so feet point up?
        // End 1 feet point +Z (if bottom is +Z).
        // End 2 feet should point +Z to match?
        // Yes.
        end2.position.set(0, 133.75, 0);
        scene.add(end2);

        // Hex Key
        const tool = createHexKey();
        tool.position.set(35, 135, 37.5);
        tool.rotation.set(Math.PI / 2, 0, 0);
        scene.add(tool);

        function animate() {
            requestAnimationFrame(animate);
            tool.rotation.z -= 0.05;
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>

</html>