<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>IKEA SMÅGÖRA Assembly - Step 3: Connect side panels</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f0f0;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            font-family: Arial, sans-serif;
            pointer-events: none;
            color: #333;
        }

        #instructions {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        #sub-instructions {
            font-size: 0.9em;
            color: #555;
        }
    </style>
</head>

<body>
    <div id="info">
        <div id="instructions">Step 3: Connect the side panels</div>
        <div id="sub-instructions">Attach both side panels to the flat end panel.</div>
    </div>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xe0e0e0);
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(100, 150, 100);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 50, 0);
        controls.update();

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(50, 200, 100); dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(2048, 2048); scene.add(dirLight);
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(500, 500), new THREE.MeshStandardMaterial({ color: 0xb0b0b0, roughness: 1.0 }));
        ground.rotation.x = -Math.PI / 2; ground.position.y = -0.1; ground.receiveShadow = true; scene.add(ground);

        const whiteWoodMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.6, metalness: 0.1 });
        const metalMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.7, roughness: 0.3 });

        function createEndPanel() {
            const width = 70; const height = 75; const thickness = 2.5;
            const shape = new THREE.Shape();
            shape.moveTo(-width / 2, -height / 2); shape.lineTo(width / 2, -height / 2);
            shape.lineTo(width / 2, height / 2 - 10); shape.quadraticCurveTo(0, height / 2, -width / 2, height / 2 - 10);
            shape.lineTo(-width / 2, -height / 2);
            const geo = new THREE.ExtrudeGeometry(shape, { depth: thickness, bevelEnabled: false });
            geo.center();
            const mesh = new THREE.Mesh(geo, whiteWoodMat); mesh.castShadow = true; return mesh;
        }

        // Modified Side Panel for Vertical Assembly
        // Length 130 is Y (Vertical). Height 70 is Z (Horizontal). Thickness 2.5 is X.
        function createSidePanelVertical() {
            const group = new THREE.Group();
            const length = 130; const height = 70; const thickness = 2.5;

            // Rails (Vertical Pillars in this orientation)
            const railGeo = new THREE.BoxGeometry(thickness, length, 5); // 5 is rail width
            const leftRail = new THREE.Mesh(railGeo, whiteWoodMat); leftRail.position.z = -height / 2 + 2.5; group.add(leftRail);
            const rightRail = new THREE.Mesh(railGeo, whiteWoodMat); rightRail.position.z = height / 2 - 2.5; group.add(rightRail);

            // Bars (Horizontal Rungs in this orientation)
            const barGeo = new THREE.CylinderGeometry(0.8, 0.8, height - 10, 16);
            for (let i = 0; i < 15; i++) {
                const bar = new THREE.Mesh(barGeo, whiteWoodMat);
                // Rotate bar to run along Z
                bar.rotation.x = Math.PI / 2;
                // Position along Y (Length)
                bar.position.y = -length / 2 + 10 + (i * (length - 20) / 14);
                group.add(bar);
            }
            return group;
        }

        function createHexKey() {
            const hexKey = new THREE.Mesh(new THREE.TorusGeometry(2, 0.4, 8, 24, Math.PI / 1.5), metalMat);
            hexKey.castShadow = true; return hexKey;
        }

        // --- ASSEMBLY ---
        // End Panel 1 (Flat on floor)
        const end1 = createEndPanel();
        end1.rotation.x = -Math.PI / 2;
        end1.position.set(0, 1.25, 0);
        scene.add(end1);

        // Side Panels (Vertical Towers)
        // End Panel Width 70 (X). Edges at +/- 35.
        // Side Panel Thickness 2.5 (X).
        // Center of Side Panel at +/- (35 - 1.25) = +/- 33.75.
        // Side Panel Height 70 (Z). Matches End Panel Width? No.
        // End Panel is 70 Wide (X). Side Panel is 70 High (Z).
        // So Side Panel runs along Z.
        // End Panel is 75 High (Z).
        // So Side Panel (70) is shorter than End Panel (75).
        // Usually aligned at the bottom?
        // End Panel Bottom is at Z = 37.5.
        // Side Panel Bottom (Rail) should align there.
        // Side Panel Center Z = 37.5 - (70/2) = 2.5.

        const side1 = createSidePanelVertical();
        side1.position.set(-33.75, 65, 2.5); // Y=65 (half length 130)
        scene.add(side1);

        const side2 = createSidePanelVertical();
        side2.position.set(33.75, 65, 2.5);
        scene.add(side2);

        // Hex Key
        const tool = createHexKey();
        tool.position.set(35, 125, 37.5); // Near top connection
        tool.rotation.set(0, Math.PI, Math.PI / 2);
        scene.add(tool);

        function animate() {
            requestAnimationFrame(animate);
            tool.rotation.z -= 0.05;
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>

</html>